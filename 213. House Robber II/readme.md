这个题可以借鉴  之前的题，把循环链表断开n种情况，然后再按照之前的方法做，这样的话，时间复杂度是O(n**2)

** 加粗部分都是针对之前思想的总结**
**  这里要把环断开，这种思想是正确的。 我之前讨论说断开有n种情况，但是这n种得到最优值是相同的 所以时间复杂度并不是O(n\*\*2)**

这个题有没有肯能O(n)时间复杂度做出来呢？ 

搜了一下discussion 还真是O(N) 时间复杂度做出来的。

让我想想，这个思路不好想啊，肯定要动态规划，但是选在哪个点会影响结果。我有一种感觉我们随机选择两个相邻的点就可以，因为我们选择一个点，按照规则，就不能选择相邻的两个点，如果我们再把相邻两个点中的一个考虑进来，算最优值就可以了


想了很久想到了一个新的思路，就是把环中一个值去掉，剩下的值形成一个链，这样的好处是首尾结点本来在环中可以邻接
  
这个题我之前用动态规划做过，但是后来看了discussion之后，我觉得他的动态规划思想更棒，更看透了问题的本质，可是现在回想他的那个方法，竟然想不起来，我需要时间来回想一下。。。。

我相出来了那个方法，但是我觉得解释性不好啊，有什么样的解释性吗？ 

关于这个可解释性的问题，我想了很久，现在想清楚了。

那个discussion里面的方法，动态规划的方法就是求在每个序列下的最大值。 递归的方法是每次来到一个新的值，形成新的序列的时候，当前新增加位置的最大值肯定是 max(f(i)+f(i-2),f(i-1))，假设这么一个场景一共有10个商店，劫匪已经枪完，并且记录了在每个商店一直到之前的商店能抢到的最大值。  这时候劫匪突然发现还有第11个商店，那在第11个位置的商店的最大值应该是多少呢？ 是不是就是我们上面提到的式子呢？ 

** 其实要相出这种动态规划的思想，我已经再动态规划那个目录里总结了方法论，严格来收，虽然上面的想法是有解释性，但是解释性仍然不够，并不能很好地引导我们去想出问题地思路 **


接下来我们回到这个题，这个是一个环的问题，这个问题我想了很久啊，我的第一个方法是如下尝试，但是下面这个方法是错误的。

假如有 [2,7,9,3,1] 这个环， 我们把2拿出来，加到9上，然后算最大值，发现这种方法不行。加到9上，虽然能保证不加和7相加，但是不能保证不和1相加

至此，我想到一个方法，我们仍然是对[2,7,9,3,1] 求最大值。但是只要保证2和1不相加就可以了，所以我们对2参与相加的位置都做个标记，最后的1避开这些标记就可以了

但是我想了一下这种方法不好，同样的问题是，可解释性不好，而且这种思想貌似也是错误的。因为我们的算法思想是让array[0]尽情地参与到最优化算法中一直到array[-2] 然后突然最后说array[0]参与地值都不用，这个会影响最后地结果地，得到错误的结果

---

以上地方法已经讨论了很多了，现在我用我地动态规划方法论来重新解释一下这个题目

首先这个题，我们要确定，无论从圆形里面哪个点开始抢劫，最终地最优值是相等地。

接下来，我们要用动态规划来做

想不出思路吧？ 用暴力方法先解

暴力方法地第一步选择肯定是抢第一个商店，和不抢第一个商店

抢第一个商店地话，最后一个商店不能抢，第二个商店不能抢。 不抢第一个商店，第二个和最后一个商店都可以抢

那么f(1:n-1) = max(array[0]+f(3:n-2),f(2:n-1))

算到这之后，我就傻乎乎地开始做递归算法了，并且觉得 索引之间有 （n-1）*n /2 种组合方式。 但是我们再来看看f（3:n-2）和f(2:n-1)不具备这种首尾不能邻接地约束。 就变成了house robber1 地问题了。所以这个问题集其实就是求两个序列地最优值，让后再比较他们地大小关系

以下代码两次ac

```
import copy

class Solution:

    def func(self, _nums):
        nums = copy.deepcopy(_nums)
        if len(nums) == 0:
            return 0
        if len(nums) <= 2:
            return max(nums)

        nums[-2] = max(nums[-2],nums[-1])
        i = len(nums) - 3
        while i >= 0:
            nums[i] = max(nums[i] + nums[i + 2], nums[i + 1])
            i -= 1
        return nums[0]

    def rob(self, nums) -> int:

        if len(nums) == 0:
            return 0
        if len(nums) <= 2:
            return max(nums)
        num1 = self.func(nums[2:-1]) + nums[0]
        num2 = self.func(nums[1:])

        return max(num1, num2)
```















