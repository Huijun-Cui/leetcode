这个题跟之前的题目有点像，有一点区别就是 输入数据包含重复的元素，我们输出的结果要求unique,我之前的做法是自己实现的\
堆栈，但是这种方式对实现 unique 结果输出不方便。用函数递归的方式倒是比较容易，接下来我用函数递归来实现一下

我想用函数递归的方式去解决的时候，我初步的思路是先给数据排序，然后在实现广度遍历算法在同一层的节点，如果当前节点的值\
跟前面节点的值相等就跳过，这样就可以保证unique result，但是又一个问题是当前节点可以选择，也可以不选择，如下举例：

1 -> 2 -> null -> 3
1 -> null -> 2 -> 3

这两个结果应该是相等的，这个应该怎么解决呢？  这个题是这个题的关键点

我在想对这种算法做出某种改进，基于ix 和 vale 值进行判断，但是没有想出来

我想了一下，感觉基于之前的函数递归的方式没法解决这个问题，可能要想想其他数据结构

我在discussion 里面搜了一下 O 关键字，想知道别人是用什么时间以获得灵感，但是他们时间复杂度有O（n**2）的\
,有 O（n*log n）的，这明显不可能啊，输出结果都是 2 \*\*n 个，时间复杂度怎么可能是 O(n\*\*2) 吗

我又自己瞎想，想可不可以把数据变成如下形式 null,1,null,2,null,3 ？ 不能。。。。

我自己又想到另一种方法，就是把相同的数修改一下，改成不相等，然后把改了哪些数标记出来。然后把这些数恢复出来。\
但是这样是不行的啊，这样我们在广度优先遍历这一部分就做不到 unique result 

这个问题，我没法解决，看答案吧 。。。。

看了网上代码，一共14行代码 ....

```
class Solution:
    def subsetsWithDup(self, nums):
        res = []
        nums.sort()
        self.dfs(nums, 0, [], res)
        return res
    
    def dfs(self, nums, index, path, res):
        res.append(path)
        for i in range(index, len(nums)):
            if i > index and nums[i] == nums[i-1]:
                continue
            self.dfs(nums, i+1, path+[nums[i]], res)
```

真的是打脸

看完这个代码之后，我知道我之前的思路是有问题的，我之前的思路是 
null -> null -> null ，那最终的返回结果是null
再假如 对应输出 [1] 这样的结果，路径对应三种情况， 1 -> null -> null , null -> 1 -> null , null -> null -> 1
这样的做法下，我的算法会遇到我前面说的那些麻烦。

通过这个问题，我的总结，当我尝试各种方法之后发现行不通，其实我的错误不是在方法实现上，而是在问题建模上。 \
这跟我之前的做类似题的时候有关系，当时我就是用这种思想来做的，现在再重新回头看看那个题，那道题是78题，可以去看看\
我的评语，我当时根本没有看明白 标准答案，我当时还纳闷为什么我用堆栈实现的代码 比 函数递归还慢，我当时还觉得是跟\
测试样例太少有关系，真的是太naive了。。。

我来总结下这种问题的特点，这个问题是广度优先遍历的经典例子，就是第一层首先放什么，让后接下来的层从剩余的元素中挑选，\
同时这个问题既然是求subset,那么路径产生过程中每个状态都是一个答案。 多么bingo的解决方案啊，真的是学习了








